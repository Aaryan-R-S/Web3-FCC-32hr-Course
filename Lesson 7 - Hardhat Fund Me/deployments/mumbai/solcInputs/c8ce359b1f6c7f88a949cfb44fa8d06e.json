{
  "language": "Solidity",
  "sources": {
    "contracts/FundMe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./PriceConverter.sol\";\n\nerror NotOwner();\n\ncontract FundMe {\n\n    // defining our library functions to be available on uint256 object\n    using PriceConverter for uint256;\n\n    mapping(address => uint256) public addressToAmountFunded;\n    address[] public funders;\n\n    // MORE GAS OPTIMIZED\n    // Could we make this constant?  /* hint: no! We should make it immutable! As we have to define its value in the constructor later */\n    address public /* immutable */ i_owner;\n    uint256 public constant MINIMUM_USD = 1 * 1e18;\n    AggregatorV3Interface public priceFeed;\n\n    constructor() {\n        i_owner = msg.sender;\n        priceFeed = AggregatorV3Interface(0x0715A7794a1dc8e42615F059dD6e406A6594651A);\n    }\n\n    function fund() public payable {\n        // first parameter of getConversionRate will be msg.value. To pass the other parameters you have to ultimately give it to the function only as parameter like msg.value.getConversionRate(\"secondParams\")\n        require(msg.value.getConversionRate(priceFeed) >= MINIMUM_USD, \"You need to spend more ETH!\");\n        // require(L4_PriceConverter.getConversionRate(msg.value) >= MINIMUM_USD, \"You need to spend more ETH!\");\n        addressToAmountFunded[msg.sender] += msg.value;\n        funders.push(msg.sender);\n    }\n    \n    function getVersion() public view returns (uint256){\n        return priceFeed.version();\n    }\n    \n    modifier onlyOwner {\n        // require(msg.sender == owner);\n        // MORE GAS OPTIMIZED\n        if (msg.sender != i_owner) revert NotOwner(); \n        _;\n    }\n    \n    function withdraw() payable onlyOwner public {\n        for (uint256 funderIndex=0; funderIndex < funders.length; funderIndex++){\n            address funder = funders[funderIndex];\n            addressToAmountFunded[funder] = 0;\n        }\n        funders = new address[](0);\n\n        // For sending money, 3 Methods:\n        // 1. Transfer - , error\n        // 2. Send - , bool\n        // 3. Call - , bool\n\n        // // transfer\n        // payable(msg.sender).transfer(address(this).balance);\n        // // send\n        // bool sendSuccess = payable(msg.sender).send(address(this).balance);\n        // require(sendSuccess, \"Send failed\");\n        // call\n        (bool callSuccess, ) = payable(msg.sender).call{value: address(this).balance}(\"\");\n        require(callSuccess, \"Call failed\");\n    }\n\n    receive() external payable {\n        fund();\n    }\n\n    fallback() external payable {\n        fund();\n    }\n\n\n    // Explainer from: https://solidity-by-example.org/fallback/\n    // Ether is sent to contract\n    //      is msg.data empty?\n    //          /   \\ \n    //         yes  no\n    //         /     \\\n    //    receive()?  fallback() \n    //     /   \\ \n    //   yes   no\n    //  /        \\\n    //receive()  fallback()\n}"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/PriceConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\n\r\n// This is not a contract but a library. This is because we will be using it in FundMe.sol as (uint).someFunctionOfThisLibrary\r\nlibrary PriceConverter {\r\n    \r\n    // We could make this public, but then we'd have to deploy it. So its \"internal\" so that no one from outside can interact with it but can easily implement it\r\n    function getPrice(AggregatorV3Interface priceFeed) internal view returns (uint256) {\r\n        // Rinkeby ETH / USD Address\r\n        // https://docs.chain.link/docs/ethereum-addresses/\r\n        // AggregatorV3Interface priceFeed = AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);\r\n        (, int256 price, , , ) = priceFeed.latestRoundData();\r\n        // USD/ETH rate with 8 extra 0s for precision\r\n        return uint256(price * 1e10);   // here we are returning rate in USD/ETH * 1e18 (i.e. extra multiplier of 1e18 to have high precision instead of \"decimal\" which has low precision)\r\n    }\r\n\r\n    function getConversionRate(uint256 ethAmount, AggregatorV3Interface priceFeed) internal view returns (uint256){\r\n        uint256 ethPrice = getPrice(priceFeed);\r\n        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18;\r\n        // the actual ETH/USD conversion rate, after adjusting the extra 0s.\r\n        return ethAmountInUsd;  // here we are returning value in USD * 1e18\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}