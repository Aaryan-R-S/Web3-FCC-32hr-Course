{
  "language": "Solidity",
  "sources": {
    "contracts/FundMe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// 1. Pragma\npragma solidity ^0.8.8;\n\n// 2. Imports\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./PriceConverter.sol\";\n\n// 3. Errors\nerror FundMe__NotOwner();\n\n// 4. Interfaces\n\n// 5. Libraries\n\n// 6. Contracts\n/** @title A contract for crowd funding\n *  @author Aaryan Raj Saxena\n *  @notice This contract is a to demo a sample funding project\n *  @dev This implements price feed as our library\n */\ncontract FundMe {\n    // defining our library functions to be available on uint256 object\n    // 1. Type Declarations\n    using PriceConverter for uint256;\n\n    // 2. State variables\n    mapping(address => uint256) private s_addressToAmountFunded;\n    address[] private s_funders;\n\n    // MORE GAS OPTIMIZED\n    // Could we make this constant?  /* hint: no! We should make it immutable! As we have to define its value in the constructor later */\n    address private immutable i_owner;\n    uint256 public constant MINIMUM_USD = 1 * 1e18;\n    AggregatorV3Interface private s_priceFeed;\n\n    // 3. Events\n\n    // 4. Events\n    modifier onlyOwner() {\n        // require(msg.sender == owner), \"FundeMe__NotOwner\";\n        // MORE GAS OPTIMIZED\n        if (msg.sender != i_owner) revert FundMe__NotOwner();\n        _;\n    }\n\n    // 5. Functions\n    // Constructor -> Receive -> Fallback -> External -> Public ->  Internal -> Private -> View -> Pure\n    constructor(address priceFeedAddress) {\n        i_owner = msg.sender;\n        s_priceFeed = AggregatorV3Interface(priceFeedAddress);\n    }\n\n    receive() external payable {\n        fund();\n    }\n\n    fallback() external payable {\n        fund();\n    }\n\n    // Explainer from: https://solidity-by-example.org/fallback/\n    // Ether is sent to contract\n    //      is msg.data empty?\n    //          /   \\\n    //         yes  no\n    //         /     \\\n    //    receive()?  fallback()\n    //     /   \\\n    //   yes   no\n    //  /        \\\n    //receive()  fallback() \n\n    /** @notice This function funds this contract \n     *  @dev This implements price feed as our library\n    */\n    function fund() public payable {\n        // first parameter of getConversionRate will be msg.value. To pass the other parameters you have to ultimately give it to the function only as parameter like msg.value.getConversionRate(\"secondParams\")\n        require(\n            msg.value.getConversionRate(s_priceFeed) >= MINIMUM_USD,\n            \"You need to spend more ETH!\"\n        );\n        // require(L4_PriceConverter.getConversionRate(msg.value) >= MINIMUM_USD, \"You need to spend more ETH!\");\n        s_addressToAmountFunded[msg.sender] += msg.value;\n        s_funders.push(msg.sender);\n    }\n\n    /** @notice This function withdraw funds from this contract \n    */\n    function withdraw() public payable onlyOwner {\n        for (\n            uint256 funderIndex = 0;\n            funderIndex < s_funders.length;\n            funderIndex++\n        ) {\n            address funder = s_funders[funderIndex];\n            s_addressToAmountFunded[funder] = 0;\n        }\n        s_funders = new address[](0);\n\n        // For sending money, 3 Methods:\n        // 1. Transfer - , error\n        // 2. Send - , bool\n        // 3. Call - , bool\n\n        // // transfer\n        // payable(msg.sender).transfer(address(this).balance);\n        // // send\n        // bool sendSuccess = payable(msg.sender).send(address(this).balance);\n        // require(sendSuccess, \"Send failed\");\n        // call\n        (bool callSuccess, ) = payable(msg.sender).call{ value: address(this).balance }(\"\");\n        require(callSuccess, \"Call failed\");\n    }\n\n    function cheaperWithdraw() public onlyOwner {\n        address[] memory funders = s_funders;\n        for (uint256 funderIndex = 0; funderIndex < funders.length; funderIndex++) {\n            address funder = funders[funderIndex];\n            // mappings can't be in memory, sorry!\n            s_addressToAmountFunded[funder] = 0;\n        }\n        s_funders = new address[](0);\n        (bool callSuccess, ) = payable(msg.sender).call{ value: address(this).balance }(\"\");\n        require(callSuccess, \"Call failed\");\n    }\n\n    function getAddressToAmountFunded(address fundingAddress) public view returns (uint256){\n        return s_addressToAmountFunded[fundingAddress];\n    }    \n    \n    function getFunder(uint256 index) public view returns (address) {\n        return s_funders[index];\n    }\n\n    function getOwner() public view returns (address) {\n        return i_owner;\n    }\n\n    function getVersion() public view returns (uint256) {\n        return s_priceFeed.version();\n    }\n\n    function getPriceFeed() public view returns (AggregatorV3Interface) {\n        return s_priceFeed;\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/PriceConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\n\r\n// This is not a contract but a library. This is because we will be using it in FundMe.sol as (uint).someFunctionOfThisLibrary\r\nlibrary PriceConverter {\r\n    \r\n    // We could make this public, but then we'd have to deploy it. So its \"internal\" so that no one from outside can interact with it but can easily implement it\r\n    function getPrice(AggregatorV3Interface priceFeed) internal view returns (uint256) {\r\n        // Rinkeby ETH / USD Address\r\n        // https://docs.chain.link/docs/ethereum-addresses/\r\n        // AggregatorV3Interface priceFeed = AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);\r\n        (, int256 price, , , ) = priceFeed.latestRoundData();\r\n        // USD/ETH rate with 8 extra 0s for precision\r\n        return uint256(price * 1e10);   // here we are returning rate in USD/ETH * 1e18 (i.e. extra multiplier of 1e18 to have high precision instead of \"decimal\" which has low precision)\r\n    }\r\n\r\n    function getConversionRate(uint256 ethAmount, AggregatorV3Interface priceFeed) internal view returns (uint256){\r\n        uint256 ethPrice = getPrice(priceFeed);\r\n        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18;\r\n        // the actual ETH/USD conversion rate, after adjusting the extra 0s.\r\n        return ethAmountInUsd;  // here we are returning value in USD * 1e18\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}